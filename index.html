<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZenGrid Hitori - Developed by Bikram</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, rgba(222, 184, 135, 0.9) 0%, rgba(205, 164, 116, 0.9) 100%), 
                        url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAGQAZADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD3+iiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/2Q==') no-repeat center center fixed;
            background-size: cover;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        /* Zen Background with animated elements - updated colors */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(139, 102, 79, 0.1);
            z-index: -2;
            animation: breathe 4s ease-in-out infinite;
        }

        @keyframes breathe {
            0%, 100% { opacity: 0.1; }
            50% { opacity: 0.2; }
        }

        /* Floating zen elements */
        .zen-element {
            position: fixed;
            opacity: 0.1;
            animation: float 6s ease-in-out infinite;
            z-index: -1;
            pointer-events: none;
            font-size: 2rem;
        }

        .zen-element:nth-child(1) {
            top: 10%;
            left: 10%;
            animation-delay: 0s;
        }

        .zen-element:nth-child(2) {
            top: 20%;
            right: 15%;
            animation-delay: 2s;
        }

        .zen-element:nth-child(3) {
            bottom: 15%;
            left: 20%;
            animation-delay: 4s;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }

        .container {
            background: rgba(245, 231, 201, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(139, 102, 79, 0.3);
            backdrop-filter: blur(20px);
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            text-align: center;
            position: relative;
            overflow: hidden;
            animation: slideIn 0.8s ease-out;
            border: 2px solid rgba(139, 102, 79, 0.2);
        }

        @keyframes slideIn {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(205, 164, 116, 0.1), transparent);
            transform: rotate(45deg);
            animation: shimmer 4s ease-in-out infinite;
            z-index: 1;
            pointer-events: none;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%) rotate(45deg); }
            50% { transform: translateX(100%) rotate(45deg); }
        }

        .content {
            position: relative;
            z-index: 2;
        }

        /* Loading Screen */
        .loading-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 4px solid #e3e3e3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 2rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Title Screen with Entry Image */
        .title-screen {
            background: url('data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAADAEADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD/2Q==') no-repeat center center;
            background-size: contain;
            background-color: rgba(222, 184, 135, 0.95);
            border-radius: 15px;
            padding: 3rem 2rem;
            margin: 1rem;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .title-screen h1 {
            font-size: 0;
            height: 0;
            overflow: hidden;
            margin: 0;
        }

        .developer-credit {
            color: rgba(139, 102, 79, 0.8);
            font-size: 1.1rem;
            margin-bottom: 2rem;
            font-style: italic;
            margin-top: auto;
        }

        /* Menu and Buttons - updated zen colors */
        .menu {
            display: none;
            flex-direction: column;
            gap: 1rem;
        }

        .menu-btn, .control-btn, .submit-btn, .back-btn, .resume-btn {
            background: linear-gradient(135deg, #8B6F47, #A0845C);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 15px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(139, 111, 71, 0.3);
            position: relative;
            overflow: hidden;
            user-select: none;
        }

        .menu-btn:hover, .control-btn:hover, .submit-btn:hover, .back-btn:hover, .resume-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 111, 71, 0.4);
            background: linear-gradient(135deg, #A0845C, #8B6F47);
        }

        .menu-btn:active, .control-btn:active, .submit-btn:active, .back-btn:active, .resume-btn:active {
            transform: translateY(0) scale(0.98);
            animation: vibrate 0.3s ease-in-out;
        }

        @keyframes vibrate {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        /* Game Screen */
        .game-screen {
            display: none;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .game-info {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .timer, .hints-left {
            background: linear-gradient(135deg, #8B6F47, #A0845C);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 25px;
            font-weight: bold;
            font-size: 0.9rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(139, 111, 71, 0.3); }
            50% { box-shadow: 0 0 20px rgba(139, 111, 71, 0.6); }
        }

        .game-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .control-btn {
            background: rgba(139, 111, 71, 0.1);
            border: 2px solid #8B6F47;
            color: #8B6F47;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: #8B6F47;
            color: white;
        }

        .submit-btn {
            background: linear-gradient(135deg, #4caf50, #45a049);
            margin-top: 1rem;
            font-size: 1.2rem;
            padding: 1rem 2rem;
            animation: submitPulse 2s infinite;
        }

        @keyframes submitPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(76, 175, 80, 0.3); }
            50% { box-shadow: 0 0 20px rgba(76, 175, 80, 0.6); }
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: #ddd;
            padding: 2px;
            border-radius: 10px;
            margin: 1rem auto;
            max-width: 400px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            position: relative;
            border-radius: 4px;
        }

        .cell:hover {
            background: #f0f0f0;
            transform: scale(1.05);
        }

        .cell:active {
            animation: cellVibrate 0.2s ease-in-out;
        }

        @keyframes cellVibrate {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(0.95); }
        }

        .cell.shaded {
            background: #333;
            color: white;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .cell.highlighted {
            background: #F5E7CD;
            animation: hintPulse 2s ease-in-out;
            box-shadow: 0 0 15px rgba(205, 164, 116, 0.8);
        }

        @keyframes hintPulse {
            0%, 100% { transform: scale(1); background: #F5E7CD; }
            50% { transform: scale(1.1); background: #E6D3A3; }
        }

        /* Feedback Modal */
        .feedback-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .feedback-content {
            background: white;
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            animation: slideUp 0.5s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .error-list {
            text-align: left;
            margin: 1rem 0;
            padding: 1rem;
            background: #f5f5f5;
            border-radius: 10px;
        }

        .error-item {
            color: #d32f2f;
            margin-bottom: 0.5rem;
        }

        /* Other screens - updated zen colors */
        .how-to-play, .about-game, .statistics {
            display: none;
            text-align: left;
        }

        .how-to-play h2, .about-game h2, .statistics h2 {
            color: #8B6F47;
            margin-bottom: 1rem;
            text-align: center;
        }

        .rule, .about-section, .stat-item {
            background: rgba(139, 111, 71, 0.1);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            border-left: 4px solid #8B6F47;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .victory-screen {
            display: none;
            text-align: center;
        }

        .victory-screen h2 {
            color: #4caf50;
            font-size: 2rem;
            margin-bottom: 1rem;
            animation: victoryBounce 1s ease-in-out;
        }

        @keyframes victoryBounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .paused-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(139, 102, 79, 0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            border-radius: 20px;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .resume-btn {
            background: linear-gradient(135deg, #4caf50, #45a049);
            margin-top: 2rem;
            font-size: 1.2rem;
        }

        @media (max-width: 600px) {
            .container { padding: 1rem; }
            .title-screen h1 { font-size: 2rem; }
            .grid { max-width: 300px; }
            .cell { font-size: 1rem; }
            .game-header { flex-direction: column; }
        }
    </style>
</head>
<body>
    <!-- Zen floating elements -->
    <div class="zen-element">🕸️</div>
    <div class="zen-element">🌸</div>
    <div class="zen-element">🍃</div>
    
    <div class="container">
        <!-- Pause Overlay with Resume Button -->
        <div class="paused-overlay" id="pauseOverlay">
            <div>⏸️ GAME PAUSED</div>
            <div style="font-size: 1rem; margin-top: 1rem;">Click Resume to continue</div>
            <button class="resume-btn" onclick="togglePause()">▶️ Resume Game</button>
        </div>
        
        <div class="content">
            <!-- Loading Screen -->
            <div class="loading-screen" id="loadingScreen">
                <div class="loader"></div>
                <h2>Loading ZenGrid Hitori...</h2>
                <p>Preparing your zen puzzle experience</p>
                 <p>This game developed by Bikram</p>
            </div>

            <!-- Title Screen -->
            <div class="title-screen" id="titleScreen" style="display: none;">
                <h1>ZenGrid Hitori</h1>
                <div class="developer-credit">Developed by Bikram</div>
                <button class="menu-btn" onclick="showMenu()">Enter Game</button>
            </div>

            <!-- Main Menu -->
            <div class="menu" id="mainMenu">
                <h2 style="color: #667eea; margin-bottom: 1rem;">Main Menu</h2>
                <button class="menu-btn" onclick="startGame()">🎯 Start Game</button>
                <button class="menu-btn" onclick="showHowToPlay()">📚 How to Play</button>
                <button class="menu-btn" onclick="showAboutGame()">🎌 About Hitori</button>
                <button class="menu-btn" onclick="showStatistics()">📊 Statistics</button>
            </div>

            <!-- Game Screen -->
            <div class="game-screen" id="gameScreen">
                <div class="game-header">
                    <div class="game-info">
                        <div class="timer" id="timer">00:00</div>
                        <div class="hints-left" id="hintsLeft">Hints: 3</div>
                    </div>
                    <div class="game-controls">
                        <button class="control-btn" onclick="togglePause()" id="pauseBtn">⏸️ Pause</button>
                        <button class="control-btn" onclick="getHint()">💡 Hint</button>
                        <button class="control-btn" onclick="restartGame()">🔄 Restart</button>
                        <button class="control-btn" onclick="showMenu()">🏠 Menu</button>
                    </div>
                </div>
                <div class="grid" id="gameGrid"></div>
                <button class="submit-btn" onclick="submitSolution()">✅ Submit Solution</button>
            </div>

            <!-- Feedback Modal -->
            <div class="feedback-modal" id="feedbackModal">
                <div class="feedback-content">
                    <h3 id="feedbackTitle">Game Status</h3>
                    <div id="feedbackMessage"></div>
                    <div id="errorsList" class="error-list" style="display: none;"></div>
                    <div style="margin-top: 1rem;">
                        <button class="menu-btn" onclick="closeFeedback()" style="margin: 0.5rem;">OK</button>
                        <button class="menu-btn" onclick="nextGameFromModal()" style="margin: 0.5rem; background: linear-gradient(135deg, #4caf50, #45a049);">▶️ Next</button>
                    </div>
                </div>
            </div>

            <!-- How to Play Screen -->
            <div class="how-to-play" id="howToPlayScreen">
                <h2>How to Play Hitori</h2>
                <div class="rule">
                    <h3>🎯 Objective</h3>
                    <p>Shade some cells so that no number appears more than once in any row or column.</p>
                </div>
                <div class="rule">
                    <h3>📋 Rules</h3>
                    <p><strong>1.</strong> Click cells to shade them black</p>
                    <p><strong>2.</strong> No two shaded cells can be adjacent (horizontally or vertically)</p>
                    <p><strong>3.</strong> All unshaded cells must remain connected</p>
                    <p><strong>4.</strong> Each row and column can have each number only once (in unshaded cells)</p>
                </div>
                <div class="rule">
                    <h3>💡 Tips</h3>
                    <p>• Start with numbers that appear most frequently</p>
                    <p>• Use the hint system when stuck (3 hints per game)</p>
                    <p>• Think ahead - shading cells affects connectivity</p>
                    <p>• Use the Submit button to check your progress</p>
                </div>
                <button class="back-btn" onclick="showMenu()">Back to Menu</button>
            </div>

            <!-- About Hitori Screen -->
            <div class="about-game" id="aboutGameScreen">
                <h2>About Hitori</h2>
                <div class="about-section">
                    <h3>🎌 What is Hitori?</h3>
                    <p>Hitori (ひとり) is a Japanese logic puzzle game whose name literally means "alone" or "leave me alone". It's a number-based puzzle that challenges players to eliminate duplicates while maintaining specific constraints.</p>
                </div>
                <div class="about-section">
                    <h3>📚 History</h3>
                    <p>Hitori was created by the famous Japanese puzzle company Nikoli, the same company behind Sudoku and Kakuro. Nikoli was founded in 1980 by Maki Kaji, who is often called the "Godfather of Sudoku".</p>
                </div>
                <div class="about-section">
                    <h3>🧘 The Zen Philosophy</h3>
                    <p>Like many Japanese puzzles, Hitori embodies principles of minimalism and balance. The act of "leaving numbers alone" by shading them reflects the Zen concept of knowing when to act and when to refrain from action.</p>
                </div>
                <button class="back-btn" onclick="showMenu()">Back to Menu</button>
            </div>

            <!-- Statistics Screen -->
            <div class="statistics" id="statisticsScreen">
                <h2>Statistics</h2>
                <div class="stat-item">
                    <span>Best Time</span>
                    <span id="bestTime">--:--</span>
                </div>
                <div class="stat-item">
                    <span>Games Completed</span>
                    <span id="gamesCompleted">0</span>
                </div>
                <div class="stat-item">
                    <span>Average Time</span>
                    <span id="averageTime">--:--</span>
                </div>
                <button class="back-btn" onclick="showMenu()">Back to Menu</button>
            </div>

            <!-- Victory Screen -->
            <div class="victory-screen" id="victoryScreen">
                <h2>🎉 Congratulations!</h2>
                <div class="time-display" id="completionTime">Time: 00:00</div>
                <p id="bestTimeMessage"></p>
                <div style="margin-top: 2rem;">
                    <button class="menu-btn" onclick="nextGame()" style="margin: 0.5rem;">▶️ Next Game</button>
                    <button class="menu-btn" onclick="showMenu()" style="margin: 0.5rem;">🏠 Main Menu</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Audio elements for sound effects -->
    <audio id="victorySound" preload="auto">
        <source src="data:audio/wav;base64,UklGRvIGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmEfCTyQ2e2TQAkOW7Lh5KZUG" type="audio/wav">
    </audio>

    <script>
        class HitoriGame {
            constructor() {
                this.grid = [];
                this.solution = [];
                this.currentGrid = [];
                this.gridSize = 8;
                this.startTime = null;
                this.elapsedTime = 0;
                this.timerInterval = null;
                this.isPaused = false;
                this.hintsUsed = 0;
                this.maxHints = 3;
                this.currentHintIndex = 0;
                this.availableHints = [];
                this.originalGrid = [];
                this.gameStarted = false; // Track if player has made first move
                
                this.loadStatistics();
            }

            generatePuzzle() {
                // Generate completely random puzzle for endless gameplay
                this.createRandomGrid();
                this.addRandomDuplicates();
                this.calculateSolution();
                this.prepareHints();
                
                // Store original grid for restart functionality
                this.originalGrid = JSON.parse(JSON.stringify(this.grid));
                
                this.renderGrid();
            }

            createRandomGrid() {
                // Create a completely random 8x8 grid with numbers 1-8
                this.grid = [];
                for (let row = 0; row < this.gridSize; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        // Use different random patterns for infinite variety
                        let num;
                        const pattern = Math.floor(Math.random() * 5);
                        
                        switch(pattern) {
                            case 0: // Diagonal pattern
                                num = ((row + col) % this.gridSize) + 1;
                                break;
                            case 1: // Reverse diagonal
                                num = ((row - col + this.gridSize) % this.gridSize) + 1;
                                break;
                            case 2: // Circular pattern
                                num = ((row * 2 + col) % this.gridSize) + 1;
                                break;
                            case 3: // Random with constraints
                                num = ((row * 3 + col * 2) % this.gridSize) + 1;
                                break;
                            default: // Pure random
                                num = Math.floor(Math.random() * this.gridSize) + 1;
                        }
                        
                        // Add randomization to make each puzzle unique
                        if (Math.random() < 0.4) {
                            num = Math.floor(Math.random() * this.gridSize) + 1;
                        }
                        
                        this.grid[row][col] = num;
                    }
                }
            }

            addRandomDuplicates() {
                const numDuplicateGroups = 8 + Math.floor(Math.random() * 8); // 8-15 duplicate groups
                
                for (let i = 0; i < numDuplicateGroups; i++) {
                    const createRowDuplicate = Math.random() < 0.5;
                    
                    if (createRowDuplicate) {
                        // Create row duplicate
                        const row = Math.floor(Math.random() * this.gridSize);
                        const col1 = Math.floor(Math.random() * this.gridSize);
                        const col2 = Math.floor(Math.random() * this.gridSize);
                        
                        if (col1 !== col2) {
                            this.grid[row][col2] = this.grid[row][col1];
                        }
                    } else {
                        // Create column duplicate
                        const col = Math.floor(Math.random() * this.gridSize);
                        const row1 = Math.floor(Math.random() * this.gridSize);
                        const row2 = Math.floor(Math.random() * this.gridSize);
                        
                        if (row1 !== row2) {
                            this.grid[row2][col] = this.grid[row1][col];
                        }
                    }
                }
            }

            calculateSolution() {
                this.solution = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(false));
                
                // Find all cells that need to be shaded to eliminate duplicates
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.shouldBeShaded(row, col)) {
                            this.solution[row][col] = true;
                        }
                    }
                }
            }

            shouldBeShaded(row, col) {
                const currentNum = this.grid[row][col];
                
                // Find first occurrence of this number in the row
                let firstInRow = -1;
                for (let c = 0; c < this.gridSize; c++) {
                    if (this.grid[row][c] === currentNum) {
                        firstInRow = c;
                        break;
                    }
                }
                
                // Find first occurrence of this number in the column
                let firstInCol = -1;
                for (let r = 0; r < this.gridSize; r++) {
                    if (this.grid[r][col] === currentNum) {
                        firstInCol = r;
                        break;
                    }
                }
                
                // Shade if this is NOT the first occurrence in row or column
                let shouldShade = false;
                
                // Check row duplicates
                if (firstInRow !== col) {
                    for (let c = 0; c < this.gridSize; c++) {
                        if (c !== col && this.grid[row][c] === currentNum) {
                            shouldShade = true;
                            break;
                        }
                    }
                }
                
                // Check column duplicates
                if (firstInCol !== row) {
                    for (let r = 0; r < this.gridSize; r++) {
                        if (r !== row && this.grid[r][col] === currentNum) {
                            shouldShade = true;
                            break;
                        }
                    }
                }
                
                return shouldShade && (col > firstInRow || row > firstInCol);
            }

            prepareHints() {
                // Prepare all hint positions for sequential hints
                this.availableHints = [];
                this.currentHintIndex = 0;
                
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.solution[row][col]) {
                            this.availableHints.push([row, col]);
                        }
                    }
                }
                
                // Shuffle hints for variety
                this.shuffleArray(this.availableHints);
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            renderGrid() {
                const gridElement = document.getElementById('gameGrid');
                gridElement.innerHTML = '';
                
                this.currentGrid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(false));
                
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.textContent = this.grid[row][col];
                        cell.onclick = () => this.toggleCell(row, col);
                        cell.id = `cell-${row}-${col}`;
                        gridElement.appendChild(cell);
                    }
                }
            }

            toggleCell(row, col) {
                if (this.isPaused) return;
                
                // Start timer on first move
                if (!this.gameStarted) {
                    this.gameStarted = true;
                    this.startTimer();
                }
                
                // Add vibration effect
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
                
                this.currentGrid[row][col] = !this.currentGrid[row][col];
                const cell = document.getElementById(`cell-${row}-${col}`);
                
                if (this.currentGrid[row][col]) {
                    cell.classList.add('shaded');
                } else {
                    cell.classList.remove('shaded');
                }
            }

            getHint() {
                if (this.hintsUsed >= this.maxHints || this.isPaused) return;
                
                // Add vibration effect
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100]);
                }
                
                this.hintsUsed++;
                document.getElementById('hintsLeft').textContent = `Hints: ${this.maxHints - this.hintsUsed}`;
                
                // Find next available hint that hasn't been shown yet
                let hintFound = false;
                let attempts = 0;
                
                while (!hintFound && attempts < this.availableHints.length) {
                    if (this.currentHintIndex >= this.availableHints.length) {
                        this.currentHintIndex = 0; // Reset if we've shown all hints
                    }
                    
                    const [row, col] = this.availableHints[this.currentHintIndex];
                    
                    // Only show hint if this cell isn't already shaded correctly
                    if (this.solution[row][col] && !this.currentGrid[row][col]) {
                        const cell = document.getElementById(`cell-${row}-${col}`);
                        cell.classList.add('highlighted');
                        setTimeout(() => {
                            cell.classList.remove('highlighted');
                        }, 3000);
                        hintFound = true;
                    }
                    
                    this.currentHintIndex++;
                    attempts++;
                }
            }

            submitSolution() {
                if (this.isPaused) return;
                
                // Add vibration effect
                if (navigator.vibrate) {
                    navigator.vibrate([50, 100, 50]);
                }
                
                // Count shaded cells
                let shadedCount = 0;
                let totalSolutionCells = 0;
                
                // Count solution cells and current shaded cells
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.solution[row][col]) {
                            totalSolutionCells++;
                        }
                        if (this.currentGrid[row][col]) {
                            shadedCount++;
                        }
                    }
                }
                
                const errors = this.checkSolution();
                
                // Case 1: Haven't started the game (no cells shaded)
                if (shadedCount === 0) {
                    this.showFeedback([], "🤔 You haven't shaded a single cell yet!", "Start by identifying duplicate numbers in rows and columns.");
                }
                // Case 2: Some cells shaded, all correct, but not complete
                else if (shadedCount < totalSolutionCells && errors.length === 0) {
                    this.showFeedback([], "👍 Getting better, keep going!", `You have ${shadedCount}/${totalSolutionCells} correct cells shaded. Continue finding the remaining duplicates!`);
                }
                // Case 3: Some cells shaded, but some/all are wrong
                else if (shadedCount < totalSolutionCells && errors.length > 0) {
                    this.showFeedback(errors, "😬 Oops, you made mistakes!", "Check the errors below and try again.");
                }
                // Case 4: All cells correctly shaded - Victory!
                else if (shadedCount === totalSolutionCells && errors.length === 0) {
                    this.showFeedback([], "🎉 Congratulations, you did it! 🏆", `Perfect solution! You completed it in ${this.formatTime(this.elapsedTime)}.`);
                    this.handleVictory();
                }
                // Case 5: All cells shaded but some are wrong
                else if (errors.length > 0) {
                    this.showFeedback(errors, "😬 Oops, you made mistakes!", "You've shaded cells, but some are incorrect. Check the errors below.");
                }
            }

            checkSolution() {
                const errors = [];
                
                // Check if solution matches the correct pattern
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.solution[row][col] && !this.currentGrid[row][col]) {
                            errors.push(`Cell at row ${row + 1}, column ${col + 1} should be shaded`);
                        } else if (!this.solution[row][col] && this.currentGrid[row][col]) {
                            errors.push(`Cell at row ${row + 1}, column ${col + 1} should NOT be shaded`);
                        }
                    }
                }
                
                // Check for adjacent shaded cells
                const adjacentErrors = new Set();
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.currentGrid[row][col]) {
                            const adjacent = [
                                [row - 1, col], [row + 1, col],
                                [row, col - 1], [row, col + 1]
                            ];
                            
                            for (const [adjRow, adjCol] of adjacent) {
                                if (adjRow >= 0 && adjRow < this.gridSize && 
                                    adjCol >= 0 && adjCol < this.gridSize && 
                                    this.currentGrid[adjRow][adjCol]) {
                                    const errorKey = `${Math.min(row, adjRow)},${Math.min(col, adjCol)}-${Math.max(row, adjRow)},${Math.max(col, adjCol)}`;
                                    if (!adjacentErrors.has(errorKey)) {
                                        adjacentErrors.add(errorKey);
                                        errors.push(`Adjacent shaded cells at (${row + 1}, ${col + 1}) and (${adjRow + 1}, ${adjCol + 1})`);
                                    }
                                }
                            }
                        }
                    }
                }
                
                return errors;
            }

            showFeedback(errors, title, message) {
                const modal = document.getElementById('feedbackModal');
                const titleElement = document.getElementById('feedbackTitle');
                const messageElement = document.getElementById('feedbackMessage');
                const errorsList = document.getElementById('errorsList');
                
                titleElement.textContent = title;
                messageElement.textContent = message;
                
                if (errors.length > 0) {
                    errorsList.style.display = 'block';
                    errorsList.innerHTML = errors.map(error => `<div class="error-item">• ${error}</div>`).join('');
                } else {
                    errorsList.style.display = 'none';
                }
                
                modal.style.display = 'flex';
            }

            closeFeedback() {
                document.getElementById('feedbackModal').style.display = 'none';
            }

            handleVictory() {
                this.stopTimer();
                
                // Play victory sound
                const victorySound = document.getElementById('victorySound');
                victorySound.play().catch(e => console.log('Sound not available'));
                
                // Add vibration effect
                if (navigator.vibrate) {
                    navigator.vibrate([200, 100, 200, 100, 200]);
                }
                
                // Update statistics
                this.updateStatistics();
                
                // Show victory screen
                document.getElementById('gameScreen').style.display = 'none';
                document.getElementById('victoryScreen').style.display = 'block';
                document.getElementById('completionTime').textContent = `Time: ${this.formatTime(this.elapsedTime)}`;
                
                const bestTime = localStorage.getItem('hitorieBestTime');
                if (!bestTime || this.elapsedTime < parseInt(bestTime)) {
                    localStorage.setItem('hitorieBestTime', this.elapsedTime.toString());
                    document.getElementById('bestTimeMessage').textContent = '🎉 New Best Time!';
                } else {
                    document.getElementById('bestTimeMessage').textContent = `Best: ${this.formatTime(parseInt(bestTime))}`;
                }
            }

            startTimer() {
                // Stop any existing timer first
                this.stopTimer();
                
                // Reset timer values
                this.startTime = Date.now();
                this.elapsedTime = 0;
                this.pauseStartTime = null;
                
                // Update display immediately
                document.getElementById('timer').textContent = '00:00';
                
                // Start the timer interval
                this.timerInterval = setInterval(() => {
                    if (!this.isPaused) {
                        this.elapsedTime = Date.now() - this.startTime;
                        document.getElementById('timer').textContent = this.formatTime(this.elapsedTime);
                    }
                }, 100); // Update every 100ms for smoother display
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            togglePause() {
                // Add vibration effect
                if (navigator.vibrate) {
                    navigator.vibrate(100);
                }
                
                this.isPaused = !this.isPaused;
                const pauseBtn = document.getElementById('pauseBtn');
                const overlay = document.getElementById('pauseOverlay');
                
                if (this.isPaused) {
                    pauseBtn.textContent = '▶️ Resume';
                    overlay.style.display = 'flex';
                    // Store the pause start time
                    this.pauseStartTime = Date.now();
                } else {
                    pauseBtn.textContent = '⏸️ Pause';
                    overlay.style.display = 'none';
                    // Adjust start time to account for pause duration
                    if (this.pauseStartTime) {
                        const pauseDuration = Date.now() - this.pauseStartTime;
                        this.startTime += pauseDuration;
                    }
                }
            }

            formatTime(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                return `${minutes.toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;
            }

            restart() {
                // Add vibration effect
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100]);
                }
                
                // Stop timer first
                this.stopTimer();
                
                // Reset all timer-related variables
                this.elapsedTime = 0;
                this.startTime = null;
                this.isPaused = false;
                this.hintsUsed = 0;
                this.currentHintIndex = 0;
                this.pauseStartTime = null;
                this.gameStarted = false; // Reset game started flag
                
                // Reset UI
                document.getElementById('hintsLeft').textContent = `Hints: ${this.maxHints}`;
                document.getElementById('pauseBtn').textContent = '⏸️ Pause';
                document.getElementById('pauseOverlay').style.display = 'none';
                document.getElementById('timer').textContent = '00:00';
                
                // Restore original grid (same puzzle)
                this.grid = JSON.parse(JSON.stringify(this.originalGrid));
                this.currentGrid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(false));
                
                // Re-render the same grid
                this.renderGrid();
                
                // Don't start timer - wait for first move
            }

            updateStatistics() {
                let gamesCompleted = parseInt(localStorage.getItem('hitoreGamesCompleted') || '0') + 1;
                let totalTime = parseInt(localStorage.getItem('hitoreTotalTime') || '0') + this.elapsedTime;
                
                localStorage.setItem('hitoreGamesCompleted', gamesCompleted.toString());
                localStorage.setItem('hitoreTotalTime', totalTime.toString());
            }

            loadStatistics() {
                const bestTime = localStorage.getItem('hitorieBestTime');
                const gamesCompleted = localStorage.getItem('hitoreGamesCompleted') || '0';
                const totalTime = parseInt(localStorage.getItem('hitoreTotalTime') || '0');
                
                if (document.getElementById('bestTime')) {
                    document.getElementById('bestTime').textContent = bestTime ? this.formatTime(parseInt(bestTime)) : '--:--';
                    document.getElementById('gamesCompleted').textContent = gamesCompleted;
                    document.getElementById('averageTime').textContent = gamesCompleted > 0 ? 
                        this.formatTime(Math.floor(totalTime / parseInt(gamesCompleted))) : '--:--';
                }
            }
        }

        // Game instance
        let game;

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', function() {
            // Start the loading sequence immediately
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('titleScreen').style.display = 'block';
            }, 3000); // 3 seconds as requested
        });

        // Add vibration to all buttons
        function addVibrationToButtons() {
            document.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', () => {
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                });
            });
        }

        // Navigation functions
        function showMenu() {
            document.querySelectorAll('.container > .content > div').forEach(div => {
                div.style.display = 'none';
            });
            document.getElementById('mainMenu').style.display = 'flex';
            if (game) game.stopTimer();
            addVibrationToButtons();
        }

        function startGame() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            // Create completely new game instance
            game = new HitoriGame();
            game.generatePuzzle();
            
            // Don't start timer - wait for first move
            // Timer will start when player clicks first cell
            
            addVibrationToButtons();
        }

        function nextGameFromModal() {
            // Close the modal and start a new game
            document.getElementById('feedbackModal').style.display = 'none';
            
            // Create completely new game instance with different puzzle
            game = new HitoriGame();
            game.generatePuzzle();
            
            // Don't start timer - wait for first move
            
            addVibrationToButtons();
        }

        function nextGame() {
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            // Create completely new game instance
            game = new HitoriGame();
            game.generatePuzzle();
            
            // Don't start timer - wait for first move
            
            addVibrationToButtons();
        }

        function showHowToPlay() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('howToPlayScreen').style.display = 'block';
            addVibrationToButtons();
        }

        function showAboutGame() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('aboutGameScreen').style.display = 'block';
            addVibrationToButtons();
        }

        function showStatistics() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('statisticsScreen').style.display = 'block';
            if (game) game.loadStatistics();
            addVibrationToButtons();
        }

        function restartGame() {
            if (game) game.restart();
        }

        function getHint() {
            if (game) game.getHint();
        }

        function togglePause() {
            if (game) game.togglePause();
        }

        function submitSolution() {
            if (game) game.submitSolution();
        }

        function closeFeedback() {
            if (game) game.closeFeedback();
        }

        // Initialize vibration when page loads
        document.addEventListener('DOMContentLoaded', addVibrationToButtons);
    </script>
</body>
</html>
