<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZenGrid Hitori - Developed by Bikram</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        /* Zen Background with animated elements */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>');
            opacity: 0.3;
            z-index: -2;
        }

        /* Floating zen elements */
        .zen-element {
            position: fixed;
            opacity: 0.1;
            animation: float 6s ease-in-out infinite;
            z-index: -1;
            pointer-events: none;
            font-size: 2rem;
        }

        .zen-element:nth-child(1) {
            top: 10%;
            left: 10%;
            animation-delay: 0s;
        }

        .zen-element:nth-child(2) {
            top: 20%;
            right: 15%;
            animation-delay: 2s;
        }

        .zen-element:nth-child(3) {
            bottom: 15%;
            left: 20%;
            animation-delay: 4s;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(20px);
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            text-align: center;
            position: relative;
            overflow: hidden;
            animation: slideIn 0.8s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: rotate(45deg);
            animation: shimmer 3s ease-in-out infinite;
            z-index: 1;
            pointer-events: none;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%) rotate(45deg); }
            50% { transform: translateX(100%) rotate(45deg); }
        }

        .content {
            position: relative;
            z-index: 2;
        }

        /* Loading Screen */
        .loading-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 4px solid #e3e3e3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 2rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Title Screen */
        .title-screen h1 {
            font-size: 3rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 5px rgba(102, 126, 234, 0.3)); }
            to { filter: drop-shadow(0 0 15px rgba(102, 126, 234, 0.6)); }
        }

        .developer-credit {
            color: #666;
            font-size: 1.1rem;
            margin-bottom: 2rem;
            font-style: italic;
        }

        /* Menu and Buttons */
        .menu {
            display: none;
            flex-direction: column;
            gap: 1rem;
        }

        .menu-btn, .control-btn, .submit-btn, .back-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 15px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
            user-select: none;
        }

        .menu-btn:hover, .control-btn:hover, .submit-btn:hover, .back-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .menu-btn:active, .control-btn:active, .submit-btn:active, .back-btn:active {
            transform: translateY(0) scale(0.98);
            animation: vibrate 0.3s ease-in-out;
        }

        @keyframes vibrate {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        /* Game Screen */
        .game-screen {
            display: none;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .game-info {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .timer, .hints-left {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 25px;
            font-weight: bold;
            font-size: 0.9rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(102, 126, 234, 0.3); }
            50% { box-shadow: 0 0 20px rgba(102, 126, 234, 0.6); }
        }

        .game-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .control-btn {
            background: rgba(102, 126, 234, 0.1);
            border: 2px solid #667eea;
            color: #667eea;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: #667eea;
            color: white;
        }

        .submit-btn {
            background: linear-gradient(135deg, #4caf50, #45a049);
            margin-top: 1rem;
            font-size: 1.2rem;
            padding: 1rem 2rem;
            animation: submitPulse 2s infinite;
        }

        @keyframes submitPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(76, 175, 80, 0.3); }
            50% { box-shadow: 0 0 20px rgba(76, 175, 80, 0.6); }
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: #ddd;
            padding: 2px;
            border-radius: 10px;
            margin: 1rem auto;
            max-width: 400px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            position: relative;
            border-radius: 4px;
        }

        .cell:hover {
            background: #f0f0f0;
            transform: scale(1.05);
        }

        .cell:active {
            animation: cellVibrate 0.2s ease-in-out;
        }

        @keyframes cellVibrate {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(0.95); }
        }

        .cell.shaded {
            background: #333;
            color: white;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .cell.highlighted {
            background: #fffacd;
            animation: hintPulse 2s ease-in-out;
            box-shadow: 0 0 15px rgba(255, 223, 0, 0.6);
        }

        @keyframes hintPulse {
            0%, 100% { transform: scale(1); background: #fffacd; }
            50% { transform: scale(1.1); background: #ffeb3b; }
        }

        .cell.error {
            background: #ffebee;
            color: #d32f2f;
            animation: errorShake 0.5s ease-in-out;
        }

        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Feedback Modal */
        .feedback-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .feedback-content {
            background: white;
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            animation: slideUp 0.5s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .error-list {
            text-align: left;
            margin: 1rem 0;
            padding: 1rem;
            background: #f5f5f5;
            border-radius: 10px;
        }

        /* Other screens */
        .how-to-play, .about-game, .statistics {
            display: none;
            text-align: left;
        }

        .how-to-play h2, .about-game h2, .statistics h2 {
            color: #667eea;
            margin-bottom: 1rem;
            text-align: center;
        }

        .rule, .about-section, .stat-item {
            background: rgba(102, 126, 234, 0.1);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            border-left: 4px solid #667eea;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .victory-screen {
            display: none;
            text-align: center;
        }

        .victory-screen h2 {
            color: #4caf50;
            font-size: 2rem;
            margin-bottom: 1rem;
            animation: victoryBounce 1s ease-in-out;
        }

        @keyframes victoryBounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .paused-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            border-radius: 20px;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 600px) {
            .container { padding: 1rem; }
            .title-screen h1 { font-size: 2rem; }
            .grid { max-width: 300px; }
            .cell { font-size: 1rem; }
            .game-header { flex-direction: column; }
        }
    </style>
</head>
<body>
    <!-- Zen floating elements -->
    <div class="zen-element">🕸️</div>
    <div class="zen-element">🌸</div>
    <div class="zen-element">🍃</div>
    
    <div class="container">
        <div class="paused-overlay">
            <div>
                <div>⏸️ GAME PAUSED</div>
                <div style="font-size: 1rem; margin-top: 1rem;">Click Resume to continue</div>
            </div>
        </div>
        
        <div class="content">
            <!-- Loading Screen -->
            <div class="loading-screen" id="loadingScreen">
                <div class="loader"></div>
                <h2>Loading ZenGrid Hitori...</h2>
                <p>Preparing your zen puzzle experience</p>
            </div>

            <!-- Title Screen -->
            <div class="title-screen" id="titleScreen" style="display: none;">
                <h1>ZenGrid Hitori</h1>
                <div class="developer-credit">Developed by Bikram</div>
                <button class="menu-btn" onclick="showMenu()">Enter Game</button>
            </div>

            <!-- Main Menu -->
            <div class="menu" id="mainMenu">
                <h2 style="color: #667eea; margin-bottom: 1rem;">Main Menu</h2>
                <button class="menu-btn" onclick="startGame()">🎯 Start Game</button>
                <button class="menu-btn" onclick="showHowToPlay()">📚 How to Play</button>
                <button class="menu-btn" onclick="showAboutGame()">🎌 About Hitori</button>
                <button class="menu-btn" onclick="showStatistics()">📊 Statistics</button>
            </div>

            <!-- Game Screen -->
            <div class="game-screen" id="gameScreen">
                <div class="game-header">
                    <div class="game-info">
                        <div class="timer" id="timer">00:00</div>
                        <div class="hints-left" id="hintsLeft">Hints: 3</div>
                    </div>
                    <div class="game-controls">
                        <button class="control-btn" onclick="togglePause()" id="pauseBtn">⏸️ Pause</button>
                        <button class="control-btn" onclick="getHint()">💡 Hint</button>
                        <button class="control-btn" onclick="restartGame()">🔄 Restart</button>
                        <button class="control-btn" onclick="showMenu()">🏠 Menu</button>
                    </div>
                </div>
                <div class="grid" id="gameGrid"></div>
                <button class="submit-btn" onclick="submitSolution()">✅ Submit Solution</button>
            </div>

            <!-- Feedback Modal -->
            <div class="feedback-modal" id="feedbackModal">
                <div class="feedback-content">
                    <h3 id="feedbackTitle">Game Status</h3>
                    <div id="feedbackMessage"></div>
                    <div id="errorsList" class="error-list" style="display: none;"></div>
                    <button class="menu-btn" onclick="closeFeedback()" style="margin-top: 1rem;">OK</button>
                </div>
            </div>

            <!-- How to Play Screen -->
            <div class="how-to-play" id="howToPlayScreen">
                <h2>How to Play Hitori</h2>
                <div class="rule">
                    <h3>🎯 Objective</h3>
                    <p>Shade some cells so that no number appears more than once in any row or column.</p>
                </div>
                <div class="rule">
                    <h3>📋 Rules</h3>
                    <p><strong>1.</strong> Click cells to shade them black</p>
                    <p><strong>2.</strong> No two shaded cells can be adjacent (horizontally or vertically)</p>
                    <p><strong>3.</strong> All unshaded cells must remain connected</p>
                    <p><strong>4.</strong> Each row and column can have each number only once (in unshaded cells)</p>
                </div>
                <div class="rule">
                    <h3>💡 Tips</h3>
                    <p>• Start with numbers that appear most frequently</p>
                    <p>• Use the hint system when stuck (3 hints per game)</p>
                    <p>• Think ahead - shading cells affects connectivity</p>
                    <p>• Use the Submit button to check your progress</p>
                </div>
                <button class="back-btn" onclick="showMenu()">Back to Menu</button>
            </div>

            <!-- About Hitori Screen -->
            <div class="about-game" id="aboutGameScreen">
                <h2>About Hitori</h2>
                <div class="about-section">
                    <h3>🎌 What is Hitori?</h3>
                    <p>Hitori (ひとり) is a Japanese logic puzzle game whose name literally means "alone" or "leave me alone". It's a number-based puzzle that challenges players to eliminate duplicates while maintaining specific constraints.</p>
                </div>
                <div class="about-section">
                    <h3>📚 History</h3>
                    <p>Hitori was created by the famous Japanese puzzle company Nikoli, the same company behind Sudoku and Kakuro. Nikoli was founded in 1980 by Maki Kaji, who is often called the "Godfather of Sudoku".</p>
                </div>
                <div class="about-section">
                    <h3>🧘 The Zen Philosophy</h3>
                    <p>Like many Japanese puzzles, Hitori embodies principles of minimalism and balance. The act of "leaving numbers alone" by shading them reflects the Zen concept of knowing when to act and when to refrain from action.</p>
                </div>
                <button class="back-btn" onclick="showMenu()">Back to Menu</button>
            </div>

            <!-- Statistics Screen -->
            <div class="statistics" id="statisticsScreen">
                <h2>Statistics</h2>
                <div class="stat-item">
                    <span>Best Time</span>
                    <span id="bestTime">--:--</span>
                </div>
                <div class="stat-item">
                    <span>Games Completed</span>
                    <span id="gamesCompleted">0</span>
                </div>
                <div class="stat-item">
                    <span>Average Time</span>
                    <span id="averageTime">--:--</span>
                </div>
                <button class="back-btn" onclick="showMenu()">Back to Menu</button>
            </div>

            <!-- Victory Screen -->
            <div class="victory-screen" id="victoryScreen">
                <h2>🎉 Congratulations!</h2>
                <div class="time-display" id="completionTime">Time: 00:00</div>
                <p id="bestTimeMessage"></p>
                <div style="margin-top: 2rem;">
                    <button class="menu-btn" onclick="nextGame()" style="margin: 0.5rem;">▶️ Next Game</button>
                    <button class="menu-btn" onclick="showMenu()" style="margin: 0.5rem;">🏠 Main Menu</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Audio elements for sound effects -->
    <audio id="victorySound" preload="auto">
        <source src="data:audio/wav;base64,UklGRvIGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmEfCTyQ2e2TQAkOW7Lh5KZUG" type="audio/wav">
    </audio>

    <script>
        class HitoriGame {
            constructor() {
                this.grid = [];
                this.solution = [];
                this.currentGrid = [];
                this.gridSize = 8;
                this.startTime = null;
                this.elapsedTime = 0;
                this.timerInterval = null;
                this.isPaused = false;
                this.hintsUsed = 0;
                this.maxHints = 3;
                this.loadStatistics();
            }

            generatePuzzle() {
                // Generate a challenging 8x8 Hitori puzzle
                this.grid = [
                    [1, 2, 3, 4, 2, 6, 7, 8],
                    [2, 3, 4, 5, 6, 7, 8, 1],
                    [3, 4, 5, 6, 7, 8, 1, 2],
                    [4, 5, 6, 7, 8, 1, 2, 3],
                    [5, 6, 7, 8, 1, 2, 3, 4],
                    [6, 7, 8, 1, 2, 3, 4, 5],
                    [7, 8, 1, 2, 3, 4, 5, 6],
                    [8, 1, 2, 3, 4, 5, 6, 7]
                ];

                // Add strategic duplicates for moderate-hard difficulty
                this.addDuplicates();
                this.calculateSolution();
                this.renderGrid();
            }

            addDuplicates() {
                // Add duplicates in strategic positions
                this.grid[0][4] = 1; // Same as position [0][0]
                this.grid[1][0] = 1; // Create column duplicate
                this.grid[2][1] = 3; // Same as position [2][0]
                this.grid[3][2] = 4; // Same as position [3][0]
                this.grid[4][3] = 5; // Same as position [4][0]
                this.grid[5][4] = 6; // Same as position [5][0]
                this.grid[6][5] = 7; // Same as position [6][0]
                this.grid[7][6] = 8; // Same as position [7][0]
                
                // Add more duplicates for complexity
                this.grid[1][7] = 2;
                this.grid[2][7] = 3;
                this.grid[3][7] = 4;
                this.grid[4][7] = 5;
            }

            calculateSolution() {
                this.solution = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(false));
                
                // Mark cells that should be shaded to eliminate duplicates
                // These are based on the strategic duplicates we added
                this.solution[0][4] = true; // Remove duplicate 1 in row 0
                this.solution[1][0] = true; // Remove duplicate 1 in column 0
                this.solution[2][1] = true; // Remove duplicate 3 in row 2
                this.solution[3][2] = true; // Remove duplicate 4 in row 3
                this.solution[4][3] = true; // Remove duplicate 5 in row 4
                this.solution[5][4] = true; // Remove duplicate 6 in row 5
                this.solution[6][5] = true; // Remove duplicate 7 in row 6
                this.solution[7][6] = true; // Remove duplicate 8 in row 7
                this.solution[1][7] = true; // Remove duplicate in column
                this.solution[2][7] = true; // Remove duplicate in column
                this.solution[3][7] = true; // Remove duplicate in column
                this.solution[4][7] = true; // Remove duplicate in column
            }

            renderGrid() {
                const gridElement = document.getElementById('gameGrid');
                gridElement.innerHTML = '';
                
                this.currentGrid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(false));
                
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.textContent = this.grid[row][col];
                        cell.onclick = () => this.toggleCell(row, col);
                        cell.id = `cell-${row}-${col}`;
                        gridElement.appendChild(cell);
                    }
                }
            }

            toggleCell(row, col) {
                if (this.isPaused) return;
                
                // Add vibration effect
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
                
                this.currentGrid[row][col] = !this.currentGrid[row][col];
                const cell = document.getElementById(`cell-${row}-${col}`);
                
                if (this.currentGrid[row][col]) {
                    cell.classList.add('shaded');
                } else {
                    cell.classList.remove('shaded');
                }
            }

            getHint() {
                if (this.hintsUsed >= this.maxHints || this.isPaused) return;
                
                // Add vibration effect
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100]);
                }
                
                this.hintsUsed++;
                document.getElementById('hintsLeft').textContent = `Hints: ${this.maxHints - this.hintsUsed}`;
                
                // Find a cell that should be shaded but isn't
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.solution[row][col] && !this.currentGrid[row][col]) {
                            const cell = document.getElementById(`cell-${row}-${col}`);
                            cell.classList.add('highlighted');
                            setTimeout(() => {
                                cell.classList.remove('highlighted');
                            }, 3000);
                            return;
                        }
                    }
                }
            }

            submitSolution() {
                if (this.isPaused) return;
                
                // Add vibration effect
                if (navigator.vibrate) {
                    navigator.vibrate([50, 100, 50]);
                }
                
                const errors = this.checkSolution();
                
                if (errors.length === 0) {
                    // Perfect solution
                    this.handleVictory();
                } else {
                    // Show errors
                    this.showFeedback(errors);
                }
            }

            checkSolution() {
                const errors = [];
                
                // Check if solution matches the correct pattern
                let correctCells = 0;
                let totalSolutionCells = 0;
                
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.solution[row][col]) {
                            totalSolutionCells++;
                            if (this.currentGrid[row][col]) {
                                correctCells++;
                            } else {
                                errors.push(`Cell at row ${row + 1}, column ${col + 1} should be shaded`);
                            }
                        } else if (this.currentGrid[row][col]) {
                            errors.push(`Cell at row ${row + 1}, column ${col + 1} should NOT be shaded`);
                        }
                    }
                }
                
                // Check for adjacent shaded cells
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.currentGrid[row][col]) {
                            // Check adjacent cells
                            const adjacent = [
                                [row - 1, col], [row + 1, col],
                                [row, col - 1], [row, col + 1]
                            ];
                            
                            for (const [adjRow, adjCol] of adjacent) {
                                if (adjRow >= 0 && adjRow < this.gridSize && 
                                    adjCol >= 0 && adjCol < this.gridSize && 
                                    this.currentGrid[adjRow][adjCol]) {
                                    errors.push(`Adjacent shaded cells at (${row + 1}, ${col + 1}) and (${adjRow + 1}, ${adjCol + 1})`);
                                }
                            }
                        }
                    }
                }
                
                return errors;
            }

            showFeedback(errors) {
                const modal = document.getElementById('feedbackModal');
                const title = document.getElementById('feedbackTitle');
                const message = document.getElementById('feedbackMessage');
                const errorsList = document.getElementById('errorsList');
                
                if (errors.length === 0) {
                    title.textContent = '🎉 Perfect!';
                    message.textContent = 'Congratulations! You solved the puzzle correctly!';
                    errorsList.style.display = 'none';
                } else {
                    title.textContent = '❌ Not Quite Right';
                    message.textContent = `You have ${errors.length} error(s) to fix:`;
                    errorsList.style.display = 'block';
                    errorsList.innerHTML = errors.map(error => `<div class="error-item">• ${error}</div>`).join('');
                }
                
                modal.style.display = 'flex';
            }

            closeFeedback() {
                document.getElementById('feedbackModal').style.display = 'none';
            }

            handleVictory() {
                this.stopTimer();
                
                // Play victory sound
                const victorySound = document.getElementById('victorySound');
                victorySound.play().catch(e => console.log('Sound not available'));
                
                // Add vibration effect
                if (navigator.vibrate) {
                    navigator.vibrate([200, 100, 200, 100, 200]);
                }
                
                // Update statistics
                this.updateStatistics();
                
                // Show victory screen
                document.getElementById('gameScreen').style.display = 'none';
                document.getElementById('victoryScreen').style.display = 'block';
                document.getElementById('completionTime').textContent = `Time: ${this.formatTime(this.elapsedTime)}`;
                
                const bestTime = localStorage.getItem('hitorieBestTime');
                if (!bestTime || this.elapsedTime < parseInt(bestTime)) {
                    localStorage.setItem('hitorieBestTime', this.elapsedTime.toString());
                    document.getElementById('bestTimeMessage').textContent = '🎉 New Best Time!';
                } else {
                    document.getElementById('bestTimeMessage').textContent = `Best: ${this.formatTime(parseInt(bestTime))}`;
                }
            }

            startTimer() {
                this.startTime = Date.now() - this.elapsedTime;
                this.timerInterval = setInterval(() => {
                    if (!this.isPaused) {
                        this.elapsedTime = Date.now() - this.startTime;
                        document.getElementById('timer').textContent = this.formatTime(this.elapsedTime);
                    }
                }, 1000);
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            togglePause() {
                // Add vibration effect
                if (navigator.vibrate) {
                    navigator.vibrate(100);
                }
                
                this.isPaused = !this.isPaused;
                const pauseBtn = document.getElementById('pauseBtn');
                const overlay = document.querySelector('.paused-overlay');
                
                if (this.isPaused) {
                    pauseBtn.textContent = '▶️ Resume';
                    overlay.style.display = 'flex';
                } else {
                    pauseBtn.textContent = '⏸️ Pause';
                    overlay.style.display = 'none';
                    // Reset the start time to account for pause duration
                    this.startTime = Date.now() - this.elapsedTime;
                }
            }

            formatTime(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                return `${minutes.toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;
            }

            restart() {
                // Add vibration effect
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100]);
                }
                
                this.stopTimer();
                this.elapsedTime = 0;
                this.isPaused = false;
                this.hintsUsed = 0;
                document.getElementById('hintsLeft').textContent = `Hints: ${this.maxHints}`;
                document.getElementById('pauseBtn').textContent = '⏸️ Pause';
                document.querySelector('.paused-overlay').style.display = 'none';
                
                this.generatePuzzle();
                this.startTimer();
            }

            updateStatistics() {
                let gamesCompleted = parseInt(localStorage.getItem('hitoreGamesCompleted') || '0') + 1;
                let totalTime = parseInt(localStorage.getItem('hitoreTotalTime') || '0') + this.elapsedTime;
                
                localStorage.setItem('hitoreGamesCompleted', gamesCompleted.toString());
                localStorage.setItem('hitoreTotalTime', totalTime.toString());
            }

            loadStatistics() {
                const bestTime = localStorage.getItem('hitorieBestTime');
                const gamesCompleted = localStorage.getItem('hitoreGamesCompleted') || '0';
                const totalTime = parseInt(localStorage.getItem('hitoreTotalTime') || '0');
                
                document.getElementById('bestTime').textContent = bestTime ? this.formatTime(parseInt(bestTime)) : '--:--';
                document.getElementById('gamesCompleted').textContent = gamesCompleted;
                document.getElementById('averageTime').textContent = gamesCompleted > 0 ? 
                    this.formatTime(Math.floor(totalTime / parseInt(gamesCompleted))) : '--:--';
            }
        }

        // Game instance
        let game;

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', function() {
            // Start the loading sequence immediately
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('titleScreen').style.display = 'block';
            }, 3000); // 3 seconds as requested
        });

        // Add vibration to all buttons
        function addVibrationToButtons() {
            document.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', () => {
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                });
            });
        }

        // Navigation functions
        function showMenu() {
            document.querySelectorAll('.container > .content > div').forEach(div => {
                div.style.display = 'none';
            });
            document.getElementById('mainMenu').style.display = 'flex';
            if (game) game.stopTimer();
            addVibrationToButtons();
        }

        function startGame() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            game = new HitoriGame();
            game.generatePuzzle();
            game.startTimer();
            addVibrationToButtons();
        }

        function nextGame() {
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            game = new HitoriGame();
            game.generatePuzzle();
            game.startTimer();
            addVibrationToButtons();
        }

        function showHowToPlay() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('howToPlayScreen').style.display = 'block';
            addVibrationToButtons();
        }

        function showAboutGame() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('aboutGameScreen').style.display = 'block';
            addVibrationToButtons();
        }

        function showStatistics() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('statisticsScreen').style.display = 'block';
            if (game) game.loadStatistics();
            addVibrationToButtons();
        }

        function restartGame() {
            if (game) game.restart();
        }

        function getHint() {
            if (game) game.getHint();
        }

        function togglePause() {
            if (game) game.togglePause();
        }

        function submitSolution() {
            if (game) game.submitSolution();
        }

        function closeFeedback() {
            if (game) game.closeFeedback();
        }

        // Initialize vibration when page loads
        document.addEventListener('DOMContentLoaded', addVibrationToButtons);
    </script>
</body>
</html>
